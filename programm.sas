

*----- подготовка переменных -----;
proc format;
	value event_f 0 = "инициализация" 1 = "деление" 2 = "смерть";
run;

*----- подготовка данных -----;

data coef_1;
	array a[*] a1-a4;
	array b[*] b1-b4;
	input a[*] b[*];
	datalines;
	0.21 0.02 0.5 0.24 2.0 2.1 2.2 2.3
	; 
run;

*датасет-болванка для правильной обработки первого вызова;
/*data newCells;*/
/*run;*/
/*%let cells = 0;*/



%let N = 100;
%let cells = %eval(&cells+1);
%let newCell = newCell&cells;

data colony;
	set coef_1;
	array a[*] a1-a4;
	array b[*] b1-b4;

	array  cell[&N] (0);
	array  time[&N] (0);
	array  CumTime[&N] (0);
	array event[&N] (0);

	array cur_ev[2];
	cell_N = 1; *к концу будем иметь тут суммарное количество клеток;
	&newCell = 0;
	ColonyStatus = 0;
	dummy = .; *заглушка для отбора последней записи;

	do i = 1 to &N; *итератор записей (т.е. циклов деления);
		cell_N + &newCell; *прибавляем новые клетки из предыдущей итерации;
		if cell_N > &N then leave;
		&newCell = 0; *обнуляем счетчик новых клеток;
		do cell_i = 1 to cell_N; *пробегаем по всем клеткам;
			*селектор события;
			do ev = 1 to DIM(cur_ev);
				cur_ev[ev] = rand('WEIB',a[ev],b[ev]); 
			end;
			do ev = 1 to DIM(cur_ev);
	         	if cur_ev[ev] = max(of cur_ev[*]) 
	            then do;
	          		eventIndx=ev; *мне нужен индекс для определения события;
	          		*MaxValueVar=vname(cur_ev(i));
	         	 	leave;
	     		end; 
			end;
			/*----------------*/

			select (event[cell_i]);
					when (0);
					*инициализация;
					when (1) 
						do;
						*деление;
							&newCell+1;
							if cell_N+&newCell > &N then leave;
							cell[cell_N+&newCell]  = 1;  
							time[cell_N+&newCell]  = 0; 
							event[cell_N+&newCell] = 0; *создаем новую клетку;
						end;
					when (2) 
						do; 
						*смерть;
							cell[cell_i] = .;
							event[cell_i] = .;
							time[cell_i] = .;
						end;
					otherwise;
				end;
			*генерим новое событие, если клетка не мертва;
			if event[cell_i] in (0,1) then
				do; 
					cell[cell_i]  = 1;
					event[cell_i] = eventIndx;
					time[cell_i] = max(of cur_ev[*]) ;
					CumTime[cell_i] + time[cell_i];
				end;
		end;
		
		if max(of cell[*]) = . then ColonyStatus = 1;
		if ColonyStatus = 1 then 
			do;
				output;
				leave;
			end;
			else output;
	end;

run;


data tmpStatVector (keep = cell_N);
	*Вытаскиваем из последней записи ;
	set colony;
	if last.dummy;
run;

*прицепляем динамику изменения состава популяции новым столбцом ;

data tmp;
	set colony (keep = &newCell);
run;

data newCells;
	merge newCells tmp;
run;


proc print data = tmp;
run;

proc print data = newCells;
run;
