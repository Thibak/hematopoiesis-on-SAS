options nosource nonotes;

%macro colonyIt (it,a1,a2,b1,b2,N, borderN);
    *датасет-болванка для правильной обработки первого вызова;
    data newCells;
    run;
    data result;
    run;
    data cell_Ns;
    run;
    data liveCellss;
    run;
    data cellDeaths;
    run;
*------- отсюда итератор --------;

    %do cells = 1 %to &it; * почему cells итератор абсолютно непонятно;

    %let newCell = newCell&cells;
    %let cell_N = cell_N&cells;
    %let liveCells = liveCells&cells;
    %let cellDeath = cellDeath&cells;

        data colony;

            array  cell[&N];
            array  time[&N];
            array  CumTime[&N];
            array  event[&N];

			cell[1] = 0;
            time[1] = 0;
            CumTime[1] = 0;
            event[1] = 0;

            array cur_ev[2];
            &cell_N = 1; *к концу будем иметь тут суммарное количество клеток;
            &newCell = 0;
            ColonyStatus = 1;
			brdr = 0;
            dummy = .; *заглушка для отбора последней записи;

            do i = 1 to &N; *итератор записей (т.е. циклов деления);
                &cell_N + &newCell; *прибавляем новые клетки из предыдущей итерации;
                *Счетчики новых клеток и кумулятивно-клеток;
                if &cell_N > &N then leave;
                &newCell = 0; *обнуляем счетчик новых клеток;
                &liveCells = 0; * счетчик живых клеток ;
                do cell_i = 1 to &cell_N; *пробегаем по всем клеткам;
                    *селектор события;
                  
                    cur_ev[1] = rand('WEIB',&a1,&b1);
                    cur_ev[2] = rand('WEIB',&a2,&b2);

					*a is a numeric shape parameter.;
					*b is a numeric scale parameter.;

                    do ev = 1 to DIM(cur_ev);
                        if cur_ev[ev] = min(of cur_ev[*])
                        then do;
                            eventIndx=ev; *мне нужен индекс для определения события;
                            *MaxValueVar=vname(cur_ev(i));
                            leave;
                        end;
                    end;
                    /*----------------*/

                    select (event[cell_i]);
                            when (0);
                            *инициализация;
                            when (1)
                                do;
                                *деление;
                                    &newCell+1;
                                    if &cell_N+&newCell > &N then leave;
                                    cell[&cell_N+&newCell]  = 1;
                                    time[&cell_N+&newCell]  = 0;
                                    event[&cell_N+&newCell] = 0; *создаем новую клетку;
                                end;
                            when (2)
                                do;
                                *смерть;
                                    cell[cell_i] = .;
                                    event[cell_i] = .;
                                    time[cell_i] = .;
                                end;
                            otherwise;
                        end;
                    *генерим новое событие, если клетка не мертва;
                    if event[cell_i] in (0,1) then
                        do;
                            cell[cell_i]  = 1;
                            event[cell_i] = eventIndx;
                            time[cell_i] = min(of cur_ev[*]) ;
                            CumTime[cell_i] + time[cell_i];
                            &liveCells+1;
                        end;
                end;

                /*блок рссчета показателей для вытакивания в конечный вектор-саммари*/
                CumMaxTime + max(of time[*]);
                &cellDeath = &cell_N - &liveCells;
				if &cell_N > &borderN then brdr = 1;
                N = &N;

                * Количество делений = тому, что в следующей строке;
                * Количество клеток = &cell_N;
                * Время жизни популяции = CumMaxTime;
                * количество актов деления = i ;
                * Исход (вымирание, экспонента) = ColonyStatus;
                * Количество клеток на выходе (живых) = liveCells;
                * Количество смертей/выходов -- продукция = cell_N - liveCells  т.е. вычисляемый параметр;

                /**/
                if max(of cell[*]) = . then ColonyStatus = 0; *индикатор вымирания колонии, если он не достигается, то колония считается экспоненциально разросшийся;
                if ColonyStatus = 0 then
                    do;
                        output;
                        leave;

                    end;
                    else output;
            end;
        run;

        * складываем скалярные величины в специальный датасет ;
        data tmpStatVector (keep = cell_N i CumMaxTime ColonyStatus liveCells brdr);
            *Вытаскиваем из последней записи ;
            set colony;
            by dummy;
            if last.dummy;
            cell_N = &cell_N;
            liveCells = &liveCells;
        run;

        data result;
            set result tmpStatVector;
            cellDeath = cell_N - liveCells;
			LCondPr = .;
			if brdr = 1 and ColonyStatus = 1 then LCondPr = 1;
			if brdr = 1 and ColonyStatus = 0 then LCondPr = 0;
        run;

/**обработчик горизонтальных векторов дописать;*/
/*      data tmpStatVector (keep = cell_N i CumMaxTime ColonyStatus liveCells );*/
/*          *Вытаскиваем из последней записи ;*/
/*          set colony;*/
/*          by dummy;*/
/*          if last.dummy;*/
/*          cell_N = &cell_N;*/
/*          liveCells = &liveCells;*/
/*      run;*/
/**------------------------------------------;*/
        *прицепляем динамику изменения состава популяции новым столбцом ;

        * динамика деления ;
        data tmp;
            set colony (keep = &newCell);
        run;

        data newCells;
            merge newCells tmp;
        run;

        * динамика ;
        data tmp;
            set colony (keep = &cell_N);
        run;

        data cell_Ns;
            merge cell_Ns tmp;
        run;

        * динамика ;
        data tmp;
            set colony (keep = &liveCells);
        run;

        data liveCellss;
            merge liveCellss tmp;
        run;

        * динамика ;
        data tmp;
            set colony (keep = &cellDeath);
        run;

        data cellDeaths;
            merge cellDeaths tmp;
        run;
    %end;
	    *----- конец итератора -----;
	*тут будет обработчик и складификатор итоговой статистики по запуску, средние показатели, хотя бы по вероятности исхода;
	*data FinalResult;
	proc means data = result  ; *NOPRINT;
		output out = CurMeanRes  
			mean(ColonyStatus LCondPr) = meanRes meanLCondPr 
			n(ColonyStatus LCondPr) = nRes nLCondPr 
			STDERR(ColonyStatus LCondPr) =  stdColonyStatus stdLCondPr;
	run;

/* добавить среднее количество пересечений бордера	*/

	data ExpRes;
		set ExpRes CurMeanRes;
		if (a1=.)or(a2=.)or(b1=.)or(b2=.) then 
			do;
				a1=&a1;
				a2=&a2;
				b1=&b1;
				b2=&b2;
				brdr = &borderN;
			end;
	run;

/*	proc print data = ExpRes;*/
/*	run;*/
%mend colonyIt;

%macro plotSTD(dowhlc, date, mean, std);
	data dowhlc;
		set &dowhlc;
		high = &mean + &std;
		low = &mean - &std;
	run;
	
	data dowhlc;
	   set dowhlc;
	   Dow=high; output;
	   Dow=low; output;
	   Dow=&mean; output;
	run;

	symbol1 interpol=hiloctj;

	proc gplot data=dowhlc;
	   plot dow*&date /;
	run;
	quit;
%mend;
*-------------------------------------------------------------------------;
*-------------------------------------------------------------------------;
*-------------------------------------------------------------------------;
*-------------------------------------------------------------------------;
*-------------------------------------------------------------------------;
*-------------------------------------------------------------------------;



*----- подготовка переменных -----;
proc format;
    value event_f 0 = "инициализация" 1 = "деление" 2 = "дифференцировка";
    value ColonyStatus 0 = "Колония жива" 1 = "Колония вымерла";
run;

*----- подготовка данных -----;
title1 " ";


data coef;
	array a[*] a1-a2 (1 1);
	array b[*] b1-b2 (1 1);

	limit = 100;
/*border = 5 ;*/
		do border = 0 to 30 by 1;
			output;
		end;


/*	do a1 = 0 to 2 by .2;*/
/*		output;*/
/*	end;*/
/*	a1 = 1;*/
/**/
/*	do a2 = 0 to 2 by .2;*/
/*		output;*/
/*	end;*/
/*	a2 = 1;*/

/*	do b1 = 0.01 to 2 by .1;*/
/*		do b2 = 0.01 to 2 by .1;*/
/*			output;*/
/*		end;*/
/*	end;*/
/*	b1 = 1;*/

/*	do b2 = .1 to 5 by .1;*/
/*		output;*/
/*	end;*/
/*	b2 = 1;*/

/*	input a[*] b[*];*/
/*	datalines;*/
/*	1 1 1 1.0 */
/*	1 1 1 1.1 */
/*	1 1 1 1.2 */
/*	1 1 1 1.3 */
/*	;*/
run;

*концепция обработчика: формируем датасет с "планом" эксперимента, а потом запускаем по нему скрипт. ;

	data ExpRes;
	run;

%let iteration = 500; *по причинам порядка исполнения скрипта нельзя передавать параметр макроса из датасета;
data _null_;
	set coef;
	call execute('%colonyIt(&iteration,'||a1||','||a2||','||b1||','||b2||','||limit||','||border||')');
run;

/*options source notes;*/

symbol1 interpol=join value=diamondfilled   color=vibg height=1;                                                                         
symbol2 interpol=join value=trianglefilled color=depk height=1;
/*symbol3 interpol=join value=diamondfilled  color=mob  height=2;*/
legend1 label=none frame;


proc gplot data=ExpRes;
 plot (meanRes meanLCondPr)*brdr /overlay legend=legend1; 
* haxis=45 to 155 by 10;
run;
quit;

  

%plotSTD(ExpRes, brdr, meanLCondPr, stdLCondPr);



*https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_nlin_sect036.htm;
************* Почитать тут о линейной интерполяции. Графики для конкретных распределений вероятностей по параметрам ***************;


/*proc g3grid data=ExpRes out=ExpRes3D;*/
/*   grid b1*b2 = meanRes meanLCondPr/ join; * spline smooth=.05;*/
/*run;*/
/**/
/*proc gcontour data=ExpRes3D;*/
/*   plot b1*b2 = meanRes;*/
/*   plot b1*b2 = meanLCondPr;*/
/*/overlay*/
/*run;*/
/*quit;*/
/**/
/**/
/*proc g3d data=ExpRes3D;*/
/*	plot b1*b2 = meanRes/ rotate = 250;*/
/*	plot b1*b2 = meanLCondPr/ rotate = 140;*/
/*run;*/
/*quit;*/




